# Automation 
---
## Cron job
The file named [cron](https://github.com/baadam3/Performance-and-Applicability-Analysis-of-Open-Source-Intrusion-Detection-Systems-in-Special-Purpose/blob/main/Automation/cron) contains a template of a cron job file that is a way of automation on Linux systems. Every part of the file may be changed based on the template below. Cron files could be placed into a number of different directories, in the case of this research it was plaved in **/etc/cron.d/**. To validate the timestamps the following website could be used: [crontab.guru](https://crontab.guru/).
Example format of a cron file:
```
* * * * *  user /path/to/target
| | | | |    |        |
| | | | |    |        |
| | | | |    |        +-- Path to the target file or command that the user will execute
| | | | |    +----------- The user that executes the command
| | | | +---------------- Day of the Week
| | | +------------------ Month
| | +-------------------- Day of the Month
| +---------------------- Hour
+------------------------ Minute
```
---
## IDS scripts
To take measurements the [GNU Time](https://www.gnu.org/software/time/) utility was used. This utility allows to measure certain resources used by another command. In this project, it was used with the following parameters: `/path/to/GNU/time -o /path/to/output/file -a -f '<format_of_output_log>' /monitored/tool` where `-o` creates an output file for GNU time, `-a` allows to append to the file instead of overwriting it and `-f '<format_of_output_log>'` is used to create custom format for the output log. The only "problem" with the GNU tool that it only stops the a measurement process when the measured process finished execution, but an IDS (by default) will not stop when deployed on a live network. To counter this obstacle another automation sends a `SIGNINT` to the IDS that is in use.
### Snort
The bash script [runSnort.sh](https://github.com/baadam3/Performance-and-Applicability-Analysis-of-Open-Source-Intrusion-Detection-Systems-in-Special-Purpose/blob/main/Automation/IDSs/runSnort.sh) contains the parameters needed to run the measurement process of Snort version 3. The GNU time measures the following process: `/path/to/snort -c /path/to/config -R /path/to/rules -i <NIC_interface> 2>&1 >> /path/to/snort/output/file` where `-c` reads the path to the configuration file `-R` reads the path to the rule or rules that should be used during the monitoring process, `-i` determines the NIC card that should be monitored, `2>&1` redirects the `stderr` to `stdout` (Snort version 3 sends its logs to the `stderr` stream) and `>>` appends the Snort version 3 generated logs to a file.
### Zeek
The bash script [runZeek.sh](https://github.com/baadam3/Performance-and-Applicability-Analysis-of-Open-Source-Intrusion-Detection-Systems-in-Special-Purpose/blob/main/Automation/IDSs/runZeek.sh) contains parameters to run measurements with the IDS Zeek. The GNU time measures the following process: `/path/to/zeek -i <NIC_interface> -C 2>> /path/to/zeek/output/file` where `-i` points to the NIC that should be monitored `-C` ignores invalid NIC checksums (when the message was not sent to the NIC we monitor) and `2>>` appends `stderr` output of Zeek (its own logs) to a file.
### Suricata
The bash script [runSuricata.sh](https://github.com/baadam3/Performance-and-Applicability-Analysis-of-Open-Source-Intrusion-Detection-Systems-in-Special-Purpose/blob/main/Automation/IDSs/runSuricata.sh) have the template to recreate the tests used in the research involving the IDS Suricata. The GNU time measures the following process: `/path/to/suricata -c /path/to/config -s /path/to/rules -i <NIC_interface> >> /path/to/suricata/output/file` where `-c` reads the path to the configuration file, `-s` reads the path to the rule or rules used during deployment, `-i` determines the NIC that is monitored and `>>` appends the `stdout` (logs generated by Suricata) to a file. Suricata sends its own logs to `stdout` not to `stderr` so there is no need to redirect `stderr` to `stdout`.
### Installation
In order to install the IDSs as they were during the research, the folder [IDSs](https://github.com/baadam3/SPNIDS/tree/main/Automation/IDSs) contains the scripts that automates the process. It also contins the [promisc_mode.service](https://github.com/baadam3/SPNIDS/blob/main/Automation/IDSs/promisc_mode.service) file that should be used in order to return the monitored NIC into promiscuous mode. This is a cruisal part to monitor a NIC that recieves traffic that was not ment for the given machine. This file should be set as an enabled service.

---
## Traffic generator
For the software that simulates live network traffic [Bittwist](http://bittwist.sourceforge.net/) was selected. The device running the simulation had multiple automations, one of them is [runTest.sh](https://github.com/baadam3/Performance-and-Applicability-Analysis-of-Open-Source-Intrusion-Detection-Systems-in-Special-Purpose/blob/main/Automation/Traffic_generator/runTest.sh). This script first runs bittwist on a desired interface (`-i`) useing a **file.pcap** that contains prerecorded network traffic. When the **file.pcap** is empty (the simulation is finished) it sends signals via ssh to the machines hosting IDSs to interupt (`kill -2`) the run of the IDS. When the IDS stops, the GNU time can record the used resources into the log files and the IDSs also output their own logs which are redirected to their respective files. The `kill` command needs a process ID to be stopped for example `kill -2 1234` where `-2` is the `SIGNINT` (interupt signal). Gaining these process IDs most likely will be different on other devices, the ones shown in [runTest.sh](https://github.com/baadam3/Performance-and-Applicability-Analysis-of-Open-Source-Intrusion-Detection-Systems-in-Special-Purpose/blob/main/Automation/Traffic_generator/runTest.sh) what worked on the machines used during the research. The fundamentals of that script is the machine initiates a paswordless ssh connection to the devices hosting an IDS, with some commands gains the correct process IDs, saves them into a file locally, **NOT ON THE REMOTE HOST**, and then sends the interupt signal with the correct process ID via ssh to the remote hosts.
The [copyData.sh](https://github.com/baadam3/Performance-and-Applicability-Analysis-of-Open-Source-Intrusion-Detection-Systems-in-Special-Purpose/blob/main/Automation/Traffic_generator/copyData.sh) is a bash script that runs automatically and uses the command `scp` to copy the logs from the remote hosts to the device hosting the traffic generator. This process was also automated with a cron job. The **...** means that for every file we want to copy a new version of the `scp` command should be used, for example with a different IP address or filename.
